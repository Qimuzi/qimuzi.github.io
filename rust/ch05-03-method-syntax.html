<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>方法语法</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/rust/assets/css/0.styles.fa1ca757.css" as="style"><link rel="preload" href="/rust/assets/js/app.4b754adf.js" as="script"><link rel="preload" href="/rust/assets/js/2.75a4d7fc.js" as="script"><link rel="preload" href="/rust/assets/js/37.03e3a71e.js" as="script"><link rel="prefetch" href="/rust/assets/js/10.c4d31c3a.js"><link rel="prefetch" href="/rust/assets/js/100.bd3f2cff.js"><link rel="prefetch" href="/rust/assets/js/101.abb08d4a.js"><link rel="prefetch" href="/rust/assets/js/102.f0234b1f.js"><link rel="prefetch" href="/rust/assets/js/103.3c1916d2.js"><link rel="prefetch" href="/rust/assets/js/104.0ad7dec0.js"><link rel="prefetch" href="/rust/assets/js/105.8f835ef5.js"><link rel="prefetch" href="/rust/assets/js/106.d6b036ae.js"><link rel="prefetch" href="/rust/assets/js/107.c5cc9141.js"><link rel="prefetch" href="/rust/assets/js/108.c99eb5a6.js"><link rel="prefetch" href="/rust/assets/js/109.b03eb33d.js"><link rel="prefetch" href="/rust/assets/js/11.d071ecd7.js"><link rel="prefetch" href="/rust/assets/js/110.c00ab61e.js"><link rel="prefetch" href="/rust/assets/js/111.2c636629.js"><link rel="prefetch" href="/rust/assets/js/112.ff2585e7.js"><link rel="prefetch" href="/rust/assets/js/113.2231eeca.js"><link rel="prefetch" href="/rust/assets/js/114.9fc843ff.js"><link rel="prefetch" href="/rust/assets/js/115.cb2f3157.js"><link rel="prefetch" href="/rust/assets/js/12.01431a27.js"><link rel="prefetch" href="/rust/assets/js/13.001954fa.js"><link rel="prefetch" href="/rust/assets/js/14.de568c61.js"><link rel="prefetch" href="/rust/assets/js/15.5ac216a1.js"><link rel="prefetch" href="/rust/assets/js/16.222b11f3.js"><link rel="prefetch" href="/rust/assets/js/17.b6326e99.js"><link rel="prefetch" href="/rust/assets/js/18.fb9a3204.js"><link rel="prefetch" href="/rust/assets/js/19.c40fb353.js"><link rel="prefetch" href="/rust/assets/js/20.6e099f21.js"><link rel="prefetch" href="/rust/assets/js/21.7b5f3f66.js"><link rel="prefetch" href="/rust/assets/js/22.9fc504df.js"><link rel="prefetch" href="/rust/assets/js/23.d538d1ab.js"><link rel="prefetch" href="/rust/assets/js/24.a796d785.js"><link rel="prefetch" href="/rust/assets/js/25.09bd24d4.js"><link rel="prefetch" href="/rust/assets/js/26.1e35db85.js"><link rel="prefetch" href="/rust/assets/js/27.1f871708.js"><link rel="prefetch" href="/rust/assets/js/28.8c4e7483.js"><link rel="prefetch" href="/rust/assets/js/29.1178a9ae.js"><link rel="prefetch" href="/rust/assets/js/3.683f279d.js"><link rel="prefetch" href="/rust/assets/js/30.d28dae6a.js"><link rel="prefetch" href="/rust/assets/js/31.1cc1ad6d.js"><link rel="prefetch" href="/rust/assets/js/32.4522b328.js"><link rel="prefetch" href="/rust/assets/js/33.98c6aa23.js"><link rel="prefetch" href="/rust/assets/js/34.18354973.js"><link rel="prefetch" href="/rust/assets/js/35.b656f117.js"><link rel="prefetch" href="/rust/assets/js/36.5e3be7dc.js"><link rel="prefetch" href="/rust/assets/js/38.b6004116.js"><link rel="prefetch" href="/rust/assets/js/39.012f0a72.js"><link rel="prefetch" href="/rust/assets/js/4.597ed44d.js"><link rel="prefetch" href="/rust/assets/js/40.9d015e97.js"><link rel="prefetch" href="/rust/assets/js/41.60807ed5.js"><link rel="prefetch" href="/rust/assets/js/42.71635b10.js"><link rel="prefetch" href="/rust/assets/js/43.d6f0ac7a.js"><link rel="prefetch" href="/rust/assets/js/44.ffd8f567.js"><link rel="prefetch" href="/rust/assets/js/45.68911785.js"><link rel="prefetch" href="/rust/assets/js/46.332d8d2c.js"><link rel="prefetch" href="/rust/assets/js/47.3d116305.js"><link rel="prefetch" href="/rust/assets/js/48.acd0d681.js"><link rel="prefetch" href="/rust/assets/js/49.64add7de.js"><link rel="prefetch" href="/rust/assets/js/5.9af330d4.js"><link rel="prefetch" href="/rust/assets/js/50.9def89da.js"><link rel="prefetch" href="/rust/assets/js/51.721f8e1b.js"><link rel="prefetch" href="/rust/assets/js/52.5cefa170.js"><link rel="prefetch" href="/rust/assets/js/53.d1b10d43.js"><link rel="prefetch" href="/rust/assets/js/54.39a7a255.js"><link rel="prefetch" href="/rust/assets/js/55.b2edd6e5.js"><link rel="prefetch" href="/rust/assets/js/56.fa009224.js"><link rel="prefetch" href="/rust/assets/js/57.54af133a.js"><link rel="prefetch" href="/rust/assets/js/58.33d53447.js"><link rel="prefetch" href="/rust/assets/js/59.73795052.js"><link rel="prefetch" href="/rust/assets/js/6.1c64da84.js"><link rel="prefetch" href="/rust/assets/js/60.8d9eeb18.js"><link rel="prefetch" href="/rust/assets/js/61.9a7b25dd.js"><link rel="prefetch" href="/rust/assets/js/62.4447972a.js"><link rel="prefetch" href="/rust/assets/js/63.d4935616.js"><link rel="prefetch" href="/rust/assets/js/64.77a791dd.js"><link rel="prefetch" href="/rust/assets/js/65.7d104c97.js"><link rel="prefetch" href="/rust/assets/js/66.86d487e7.js"><link rel="prefetch" href="/rust/assets/js/67.1c6e6984.js"><link rel="prefetch" href="/rust/assets/js/68.0911a62c.js"><link rel="prefetch" href="/rust/assets/js/69.6ff560c5.js"><link rel="prefetch" href="/rust/assets/js/7.1c537d43.js"><link rel="prefetch" href="/rust/assets/js/70.7b641d12.js"><link rel="prefetch" href="/rust/assets/js/71.94e85269.js"><link rel="prefetch" href="/rust/assets/js/72.56a92551.js"><link rel="prefetch" href="/rust/assets/js/73.668fc570.js"><link rel="prefetch" href="/rust/assets/js/74.d33971de.js"><link rel="prefetch" href="/rust/assets/js/75.608111f8.js"><link rel="prefetch" href="/rust/assets/js/76.622ee336.js"><link rel="prefetch" href="/rust/assets/js/77.4d928952.js"><link rel="prefetch" href="/rust/assets/js/78.a9dc776c.js"><link rel="prefetch" href="/rust/assets/js/79.05b47355.js"><link rel="prefetch" href="/rust/assets/js/8.50f79b9d.js"><link rel="prefetch" href="/rust/assets/js/80.012a9035.js"><link rel="prefetch" href="/rust/assets/js/81.42987af0.js"><link rel="prefetch" href="/rust/assets/js/82.bb693baa.js"><link rel="prefetch" href="/rust/assets/js/83.7b710a46.js"><link rel="prefetch" href="/rust/assets/js/84.18dd70f4.js"><link rel="prefetch" href="/rust/assets/js/85.d7558ad4.js"><link rel="prefetch" href="/rust/assets/js/86.0629b4df.js"><link rel="prefetch" href="/rust/assets/js/87.bb99f71a.js"><link rel="prefetch" href="/rust/assets/js/88.abb1a49a.js"><link rel="prefetch" href="/rust/assets/js/89.29e8b8f8.js"><link rel="prefetch" href="/rust/assets/js/9.00986011.js"><link rel="prefetch" href="/rust/assets/js/90.83064199.js"><link rel="prefetch" href="/rust/assets/js/91.ddb9e400.js"><link rel="prefetch" href="/rust/assets/js/92.1fcefcfb.js"><link rel="prefetch" href="/rust/assets/js/93.74430079.js"><link rel="prefetch" href="/rust/assets/js/94.178cfff1.js"><link rel="prefetch" href="/rust/assets/js/95.c6538afc.js"><link rel="prefetch" href="/rust/assets/js/96.5ef16eab.js"><link rel="prefetch" href="/rust/assets/js/97.1dc9bfe6.js"><link rel="prefetch" href="/rust/assets/js/98.058d612f.js"><link rel="prefetch" href="/rust/assets/js/99.672b17b7.js">
    <link rel="stylesheet" href="/rust/assets/css/0.styles.fa1ca757.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/rust/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/rust/" class="nav-link">
  回首页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/rust/" class="nav-link">
  回首页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>方法语法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/rust/ch05-03-method-syntax.html#方法语法" class="sidebar-link">方法语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/rust/ch05-03-method-syntax.html#定义方法" class="sidebar-link">定义方法</a></li><li class="sidebar-sub-header"><a href="/rust/ch05-03-method-syntax.html#运算符到哪去了" class="sidebar-link">-&gt; 运算符到哪去了？</a></li><li class="sidebar-sub-header"><a href="/rust/ch05-03-method-syntax.html#带有更多参数的方法" class="sidebar-link">带有更多参数的方法</a></li><li class="sidebar-sub-header"><a href="/rust/ch05-03-method-syntax.html#关联函数" class="sidebar-link">关联函数</a></li><li class="sidebar-sub-header"><a href="/rust/ch05-03-method-syntax.html#多个-impl-块" class="sidebar-link">多个 impl 块</a></li></ul></li><li><a href="/rust/ch05-03-method-syntax.html#总结" class="sidebar-link">总结</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="方法语法"><a href="#方法语法" class="header-anchor">#</a> 方法语法</h2> <blockquote><p><a href="https://github.com/rust-lang/book/blob/main/src/ch05-03-method-syntax.md" target="_blank" rel="noopener noreferrer">ch05-03-method-syntax.md<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <br>
commit b4132ae4991b16076ca2293b0c2c3283a7a1b951</p></blockquote> <p><strong>方法</strong> 与函数类似：它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，将分别在第六章和第十七章讲解），并且它们第一个参数总是 <code>self</code>，它代表调用该方法的结构体实例。</p> <h3 id="定义方法"><a href="#定义方法" class="header-anchor">#</a> 定义方法</h3> <p>让我们把前面实现的获取一个 <code>Rectangle</code> 实例作为参数的 <code>area</code> 函数，改写成一个定义于 <code>Rectangle</code> 结构体上的 <code>area</code> 方法，如示例 5-13 所示：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span> width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span>
        <span class="token string">&quot;The area of the rectangle is {} square pixels.&quot;</span><span class="token punctuation">,</span>
        rect1<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 5-13：在 <code>Rectangle</code> 结构体上定义 <code>area</code> 方法</span></p> <p>为了使函数定义于 <code>Rectangle</code> 的上下文中，我们开始了一个 <code>impl</code> 块（<code>impl</code> 是 <em>implementation</em> 的缩写），这个 <code>impl</code> 块中的所有内容都将与 <code>Rectangle</code> 类型相关联。接着将 <code>area</code> 函数移动到 <code>impl</code> 大括号中，并将签名中的第一个（在这里也是唯一一个）参数和函数体中其他地方的对应参数改成 <code>self</code>。然后在 <code>main</code> 中将我们先前调用 <code>area</code> 方法并传递 <code>rect1</code> 作为参数的地方，改成使用 <strong>方法语法</strong>（<em>method syntax</em>）在 <code>Rectangle</code> 实例上调用 <code>area</code> 方法。方法语法获取一个实例并加上一个点号，后跟方法名、圆括号以及任何参数。</p> <p>在 <code>area</code> 的签名中，使用 <code>&amp;self</code> 来替代 <code>rectangle: &amp;Rectangle</code>，<code>&amp;self</code> 实际上是 <code>self: &amp;Self</code> 的缩写。在一个 <code>impl</code> 块中，<code>Self</code> 类型是 <code>impl</code> 块的类型的别名。方法的第一个参数必须有一个名为 <code>self</code> 的<code>Self</code> 类型的参数，所以 Rust 让你在第一个参数位置上只用 <code>self</code> 这个名字来缩写。注意，我们仍然需要在 <code>self</code> 前面使用 <code>&amp;</code> 来表示这个方法借用了 <code>Self</code> 实例，就像我们在 <code>rectangle: &amp;Rectangle</code> 中做的那样。方法可以选择获得 <code>self</code> 的所有权，或者像我们这里一样不可变地借用 <code>self</code>，或者可变地借用 <code>self</code>，就跟其他参数一样。</p> <p>这里选择 <code>&amp;self</code> 的理由跟在函数版本中使用 <code>&amp;Rectangle</code> 是相同的：我们并不想获取所有权，只希望能够读取结构体中的数据，而不是写入。如果想要在方法中改变调用方法的实例，需要将第一个参数改为 <code>&amp;mut self</code>。通过仅仅使用 <code>self</code> 作为第一个参数来使方法获取实例的所有权是很少见的；这种技术通常用在当方法将 <code>self</code> 转换成别的实例的时候，这时我们想要防止调用者在转换之后使用原始的实例。</p> <p>使用方法替代函数，除了可使用方法语法和不需要在每个函数签名中重复 <code>self</code> 的类型之外，其主要好处在于组织性。我们将某个类型实例能做的所有事情都一起放入 <code>impl</code> 块中，而不是让将来的用户在我们的库中到处寻找 <code>Rectangle</code> 的功能。</p> <p>请注意，我们可以选择将方法的名称与结构中的一个字段相同。例如，我们可以在 <code>Rectangle</code> 上定义一个方法，并命名为 <code>width</code>：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code><span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">width</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">&gt;</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> rect1<span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The rectangle has a nonzero width; it is {}&quot;</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这里，我们选择让 <code>width</code> 方法的行为是如果实例的 <code>width</code> 字段的值大于 0，返回 <code>true</code>。如果该值为 0，则返回 <code>false</code>：我们可以在同名的方法中使用一个字段。我们可以在同名的方法中使用一个字段来达到任何目的。在 <code>main</code> 中，当我们在 <code>rect1.width</code> 后面加上括号时。Rust 知道我们指的是方法 <code>width</code>。当我们不使用圆括号时，Rust 知道我们指的是字段 <code>width</code>。</p> <p>通常，但并不总是如此，与字段同名的方法将被定义为只返回字段中的值，而不做其他事情。这样的方法被称为 <em>getters</em>，Rust 并不像其他一些语言那样为结构字段自动实现它们。Getters 很有用，因为你可以把字段变成私有的，但方法是公共的，这样就可以把对字段的只读访问作为该类型公共 API 的一部分。我们将在第七章中讨论什么是公有和私有，以及如何将一个字段或方法指定为公有或私有。</p> <blockquote><h3 id="运算符到哪去了"><a href="#运算符到哪去了" class="header-anchor">#</a> <code>-&gt;</code> 运算符到哪去了？</h3> <p>在 C/C++ 语言中，有两个不同的运算符来调用方法：<code>.</code> 直接在对象上调用方法，而 <code>-&gt;</code> 在一个对象的指针上调用方法，这时需要先解引用（dereference）指针。换句话说，如果 <code>object</code> 是一个指针，那么 <code>object-&gt;something()</code> 就像 <code>(*object).something()</code> 一样。</p> <p>Rust 并没有一个与 <code>-&gt;</code> 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>（<em>automatic referencing and dereferencing</em>）的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。</p> <p>他是这样工作的：当使用 <code>object.something()</code> 调用方法时，Rust 会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使 <code>object</code> 与方法签名匹配。也就是说，这些代码是等价的：</p> <div class="language-rust extra-class"><pre class="language-rust"><code># <span class="token attribute attr-name">#[derive(Debug,Copy,Clone)]</span>
# <span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span> <span class="token punctuation">{</span>
#     x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span>
#     y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span>
# <span class="token punctuation">}</span>
#
# <span class="token keyword">impl</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
#    <span class="token keyword">fn</span> <span class="token function-definition function">distance</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Point</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span> <span class="token punctuation">{</span>
#        <span class="token keyword">let</span> x_squared <span class="token operator">=</span> <span class="token keyword">f64</span><span class="token punctuation">::</span><span class="token function">powi</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>x <span class="token operator">-</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
#        <span class="token keyword">let</span> y_squared <span class="token operator">=</span> <span class="token keyword">f64</span><span class="token punctuation">::</span><span class="token function">powi</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>y <span class="token operator">-</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
#
#        <span class="token keyword">f64</span><span class="token punctuation">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x_squared <span class="token operator">+</span> y_squared<span class="token punctuation">)</span>
#    <span class="token punctuation">}</span>
# <span class="token punctuation">}</span>
# <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
# <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">5.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">6.5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distance</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>第一行看起来简洁的多。这种自动引用的行为之所以有效，是因为方法有一个明确的接收者———— <code>self</code> 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（<code>&amp;self</code>），做出修改（<code>&amp;mut self</code>）或者是获取所有权（<code>self</code>）。事实上，Rust 对方法接收者的隐式借用让所有权在实践中更友好。</p></blockquote> <h3 id="带有更多参数的方法"><a href="#带有更多参数的方法" class="header-anchor">#</a> 带有更多参数的方法</h3> <p>让我们通过实现 <code>Rectangle</code> 结构体上的另一方法来练习使用方法。这回，我们让一个 <code>Rectangle</code> 的实例获取另一个 <code>Rectangle</code> 实例，如果 <code>self</code> 能完全包含第二个长方形则返回 <code>true</code>；否则返回 <code>false</code>。一旦定义了 <code>can_hold</code> 方法，就可以编写示例 5-14 中的代码。</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust,ignore extra-class"><pre class="language-text"><code>fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre></div><p><span class="caption">示例 5-14：使用还未实现的 <code>can_hold</code> 方法</span></p> <p>同时我们希望看到如下输出，因为 <code>rect2</code> 的两个维度都小于 <code>rect1</code>，而 <code>rect3</code> 比 <code>rect1</code> 要宽：</p> <div class="language-text extra-class"><pre class="language-text"><code>Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre></div><p>因为我们想定义一个方法，所以它应该位于 <code>impl Rectangle</code> 块中。方法名是 <code>can_hold</code>，并且它会获取另一个 <code>Rectangle</code> 的不可变借用作为参数。通过观察调用方法的代码可以看出参数是什么类型的：<code>rect1.can_hold(&amp;rect2)</code> 传入了 <code>&amp;rect2</code>，它是一个 <code>Rectangle</code> 的实例 <code>rect2</code> 的不可变借用。这是可以理解的，因为我们只需要读取 <code>rect2</code>（而不是写入，这意味着我们需要一个不可变借用），而且希望 <code>main</code> 保持 <code>rect2</code> 的所有权，这样就可以在调用这个方法后继续使用它。<code>can_hold</code> 的返回值是一个布尔值，其实现会分别检查 <code>self</code> 的宽高是否都大于另一个 <code>Rectangle</code>。让我们在示例 5-13 的 <code>impl</code> 块中增加这个新的 <code>can_hold</code> 方法，如示例 5-15 所示：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code># <span class="token attribute attr-name">#[derive(Debug)]</span>
# <span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
#     width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
#     height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
# <span class="token punctuation">}</span>
#
<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Rectangle</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>width <span class="token operator">&amp;&amp;</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 5-15：在 <code>Rectangle</code> 上实现 <code>can_hold</code> 方法，它获取另一个 <code>Rectangle</code> 实例作为参数</span></p> <p>如果结合示例 5-14 的 <code>main</code> 函数来运行，就会看到期望的输出。在方法签名中，可以在 <code>self</code> 后增加多个参数，而且这些参数就像函数中的参数一样工作。</p> <h3 id="关联函数"><a href="#关联函数" class="header-anchor">#</a> 关联函数</h3> <p>所有在 <code>impl</code> 块中定义的函数被称为 <strong>关联函数</strong>（<em>associated functions</em>），因为它们与 <code>impl</code> 后面命名的类型相关。我们可以定义不以 <code>self</code> 为第一参数的关联函数（因此不是方法），因为它们并不作用于一个结构体的实例。我们已经使用了一个这样的函数，<code>String::from</code> 函数，它是在 <code>String</code> 类型上定义的。</p> <p>不是方法的关联函数经常被用作返回一个结构体新实例的构造函数，例如我们可以提供一个关联函数，它接受一个维度参数并且同时作为宽和高，这样可以更轻松的创建一个正方形 <code>Rectangle</code> 而不必指定两次同样的值：</p> <p><span class="filename">文件名: src/main.rs</span></p> <div class="language-rust extra-class"><pre class="language-rust"><code># <span class="token attribute attr-name">#[derive(Debug)]</span>
# <span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
#     width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
#     height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
# <span class="token punctuation">}</span>
#
<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">square</span><span class="token punctuation">(</span>size<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span> width<span class="token punctuation">:</span> size<span class="token punctuation">,</span> height<span class="token punctuation">:</span> size <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用结构体名和 <code>::</code> 语法来调用这个关联函数：比如 <code>let sq = Rectangle::square(3);</code>。这个方法位于结构体的命名空间中：<code>::</code> 语法用于关联函数和模块创建的命名空间。第七章会讲到模块。</p> <h3 id="多个-impl-块"><a href="#多个-impl-块" class="header-anchor">#</a> 多个 <code>impl</code> 块</h3> <p>每个结构体都允许拥有多个 <code>impl</code> 块。例如，示例 5-16 中的代码等同于示例 5-15，但每个方法有其自己的 <code>impl</code> 块。</p> <div class="language-rust extra-class"><pre class="language-rust"><code># <span class="token attribute attr-name">#[derive(Debug)]</span>
# <span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
#     width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
#     height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
# <span class="token punctuation">}</span>
#
<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Rectangle</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>width <span class="token operator">&amp;&amp;</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><span class="caption">示例 5-16：使用多个 <code>impl</code> 块重写示例 5-15</span></p> <p>这里没有理由将这些方法分散在多个 <code>impl</code> 块中，不过这是有效的语法。第十章讨论泛型和 trait 时会看到实用的多 <code>impl</code> 块的用例。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>结构体让你可以创建出在你的领域中有意义的自定义类型。通过结构体，我们可以将相关联的数据片段联系起来并命名它们，这样可以使得代码更加清晰。在 <code>impl</code> 块中，你可以定义与你的类型相关联的函数，而方法是一种相关联的函数，让你指定结构体的实例所具有的行为。</p> <p>但结构体并不是创建自定义类型的唯一方法：让我们转向 Rust 的枚举功能，为你的工具箱再添一个工具。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/rust/assets/js/app.4b754adf.js" defer></script><script src="/rust/assets/js/2.75a4d7fc.js" defer></script><script src="/rust/assets/js/37.03e3a71e.js" defer></script>
  </body>
</html>
